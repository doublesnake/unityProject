//------------------------------------------------------------------------------
// <auto-generated>
//     Ce code a été généré par un outil.
//     Version du runtime :4.0.30319.18444
//
//     Les modifications apportées à ce fichier peuvent provoquer un comportement incorrect et seront perdues si
//     le code est régénéré.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using UnityEngine;


namespace AssemblyCSharp
{
	/* Class to manage inputs and mapping */
	public class InputControl
	{
		public enum Tap{NONE,SINGLE,RELEASED,DOUBLE,DOUBLEPRESSED};
		public enum Attack{NEW,COMBO};

		public Tap tapState = Tap.NONE;
        public Attack attackState = Attack.NEW;
		// Double Tap variables
		public float tapCooldown = 0.3f;
		public float tapMaxDuration = 0.2f;
		public float runPressTime = 1f;
		public float lastTapTime = 0;
		public bool doubleTap = false;
		public bool doubleTapDown = false;
		public Direction lastKeyDown = Direction.NONE;
        public Direction lastTap = Direction.NONE;
		public float lastDashTime = 0f;


		public float sensitivity = 0.1f;

		public int playerId = 1;
		
		// State variables
		private bool doubleTapLeft;
		private bool doubleTapRight;
		private bool doubleTapDownLeft;
		private bool doubleTapDownRight;

        private Command[] attackList;
        private List<Command> possibleAttack = new List<Command>();
        public List<Command> availableAttack = new List<Command>();

		// Constructor
        public InputControl(Command[] attacks, int id)
        {
            playerId = id;
            this.attackList = attacks;

        }
		public bool left()
		{
			if (Input.GetAxis("Horizontal"+playerId.ToString()) < -sensitivity)
			{
				return true;
			}
			return false;
		}
		
		public bool up()
		{
			if (Input.GetAxis("Vertical"+playerId.ToString()) > sensitivity)
				return true;
			return false;
		}

		public bool down()
		{
			if (Input.GetAxis("Vertical"+playerId.ToString()) < -sensitivity)
				return true;
			return false;
		}
		
		public bool right()
		{
			if (Input.GetAxis("Horizontal"+playerId.ToString()) > sensitivity)
			{
				return true;
			}
			return false;
		}
		public bool weak()
		{
			if (Input.GetButtonDown ("Weak"+playerId.ToString()))
				return true;
			return false;
		}
        public bool medium()
        {
            if (Input.GetButton("Medium" + playerId.ToString()))
                return true;
            return false;
        }
		public bool isDoubleTap()
		{
			return (doubleTapLeft || doubleTapRight);
		}
		public bool validateButton(GameButton button)
        {
            bool valid = false;
            switch (button)
            {
                case GameButton.DOWN:
                    if(down()) valid = true;
                    break;
                case GameButton.DOWN_L:
                    if (down() && left()) valid = true;
                    break;
                case GameButton.DOWN_R:
                    if (down() && right()) valid = true;
                    break;
                case GameButton.LEFT:
                    if (left()) valid = true;
                    break;
                case GameButton.RIGHT:
                    if (right()) valid = true;
                    break;
                case GameButton.UP:
                    if (up()) valid = true;
                    break;
                case GameButton.UP_L:
                    if (up() && left()) valid = true;
                    break;
                case GameButton.UP_R:
                    if (up() && right()) valid = true;
                    break;
                case GameButton.WEAK:
                    if (weak()) valid = true;
                    break;
                case GameButton.MEDIUM:
                    if (medium()) valid = true;
                    break;
                case GameButton.STRONG:
                    if (weak()) valid = true;
                    break;
                default:
                    break;
            }
            return valid;
        }
		public bool isDoubleTapDown()
		{
			return ((doubleTapDownLeft || doubleTapLeft) || (doubleTapDownRight||doubleTapRight));
		}
		public void checkAttack()
		{
			availableAttack.Clear();
			List<Command> temp = new List<Command>();
            switch (attackState)
            {
                case Attack.NEW:
                    possibleAttack.Clear();
					possibleAttack.AddRange(attackList);
                    foreach(Command attack in possibleAttack)
                    {
		                if(!attack.isCombination)
		                {
		                    if(!(attack.button==GameButton.UNKNOWN || !validateButton(attack.button))) temp.Add(attack);
		                }
                       	else
                        {
                            if (!(attack.combinationKey == null || attack.combinationKey[attack.counter] == null))
                            {
                                foreach(GameButton button in attack.combinationKey[attack.counter])
                                {
                                    if(validateButton(button))
                                    {
										temp.Add(attack);
                                    }
                                }
                            }
                        }
                    }
					possibleAttack = temp;
                    if(possibleAttack.Count>0)
                    {
                        bool canAttack = false;
                        foreach(Command attack in possibleAttack)
                        {
                            attack.incrementCounter();
                            if (attack.counter == 0)
                            {
                                availableAttack.Add(attack);
                                canAttack = true;
                            }
                        }
                        if (!canAttack) attackState = Attack.COMBO;
                    }
                    break;
			case Attack.COMBO:
				foreach(Command attack in possibleAttack)
				{
					if(!attack.isCombination)
					{
						if(!(attack.button==GameButton.UNKNOWN || !validateButton(attack.button))) temp.Add(attack);
					}
					else
					{
						if (!(attack.combinationKey == null || attack.combinationKey[attack.counter] == null))
						{
							foreach(GameButton button in attack.combinationKey[attack.counter])
							{
								if(validateButton(button))
								{
									temp.Add(attack);
								}
							}
						}
					}
				}
				possibleAttack = temp;
	            if(possibleAttack.Count>0)
	            {
	                foreach(Command attack in possibleAttack)
	                {
	                    attack.incrementCounter();
	                    if (attack.counter == 0)
	                    {
	                        availableAttack.Add(attack);
	                        attackState = Attack.NEW;
	                    }
	                }
	            }
	            else
	            {
	                attackState = Attack.NEW;
	            }
	            break;
            }
		}
		public void checkInputStates()
		{
			switch (tapState) {
				case Tap.NONE:
					doubleTapDown =false;
					doubleTapLeft = false;
					doubleTapRight = false;
					if (!left() && !right())
					{
						tapState = Tap.SINGLE;
					}
					break;
				case Tap.SINGLE:
					if (left()) 
					{
						lastTap = Direction.LEFT;
						tapState = Tap.RELEASED;
						lastTapTime = Time.time;
					}
					else if (right())
					{
						lastTap = Direction.RIGHT;
						tapState = Tap.RELEASED;
						lastTapTime = Time.time;
					}
					break;
				case Tap.RELEASED:
					if (Time.time - lastTapTime < tapMaxDuration)
					{
							if(lastTap == Direction.LEFT)
							{
								if(!left())
								{
							tapState = Tap.DOUBLE;
							lastTapTime = Time.time;
								}
							}
							else if(lastTap == Direction.RIGHT)
							{
								if(!right())
								{
							tapState = Tap.DOUBLE;
							lastTapTime = Time.time;
								}
							}
					}
					else tapState = Tap.NONE;
					break;
				case Tap.DOUBLE:
				if(Time.time - lastTapTime < tapMaxDuration)
					{
						if(lastTap == Direction.LEFT)
						{
							if(right())
							{
								tapState = Tap.NONE;
							}
							else if(left())
							{
								doubleTapLeft = true;
								tapState = Tap.DOUBLEPRESSED;
							}
						}
						else if(lastTap == Direction.RIGHT)
						{
							if(left())
							{
								tapState = Tap.NONE;
							}
							else if(right())
							{
								doubleTapRight = true;
								tapState = Tap.DOUBLEPRESSED;
							}
						}
					}
					else{
						tapState = Tap.NONE;
					}
					break;
			case Tap.DOUBLEPRESSED:
				if(doubleTapLeft || doubleTapDownLeft)
				{
						doubleTapLeft = false;
						doubleTapDownLeft = true;
						if(right() || !left()) 
						{
							tapState = Tap.NONE;
							doubleTapDown = false;
							doubleTapLeft = false;
							doubleTapDownLeft = false;
						}
					}
				else if(doubleTapRight || doubleTapDownRight)
				{
						doubleTapRight = false;
						doubleTapDownRight = true;
						if(left() || !right())
						{
							tapState = Tap.NONE;
							doubleTapDown = false;
							doubleTapRight = false;
							doubleTapDownRight = false;
						}
					}
					break;
			default: 
				tapState = Tap.NONE;
				break;
			}
		}

		/*public  getCurrentKey()
		{
			if (left())
				return Direction.LEFT;
			if (right())
				return Direction.RIGHT;
			if (isJumping())
				return up;
			if (isPunching())
				return punch;
			return KeyCode.None;
		}*/
	}
}

